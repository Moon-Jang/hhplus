# 항해플러스 [1주차 과제] TDD로 개발하기
## 기본과제
- 포인트 충전, 사용에 대한 정책 추가 (잔고 부족, 최대 잔고 등)
- 주어진 4가지 기능에 대한 단위 테스트 작성

## 요구사항
### 포인트 조회
- 사용자는 포인트를 조회할 수 있다.

### 포인트 이력 조회
- 사용자는 충전/사용 이력을 조회할 수 있다.

### 포인트 충전
- 사용자는 설정한 포인트만큼 포인트를 충전할 수 있다.
- 포인트 잔고는 최소 0원 최대 1,000,000원으로 제한한다.
- 포인트 충전은 최소 1원 최대 100,000원 한다.

### 포인트 사용
- 사용자는 설정한 포인트만큼 포인트를 사용할 수 있다.
- 포인트 사용은 최소 1원 이상이어야 한다.
- 잔고가 부족할 경우, 포인트 사용은 실패하여야 한다.



# 심화 과제 (동시성 제어 보고서)

---

## 1. 동시성 제어란?

동시성 제어는 여러 프로세스나 스레드가 동시에 공유 자원(예: 데이터베이스, 메모리 등)에 접근할 때 발생할 수 있는 경쟁 조건, 데드락 등의 문제를 예방하여 데이터의 일관성과 무결성을 유지하는 기법입니다. 이러한 기법을 통해 프로그램은 여러 스레드가 안전하게 실행될 수 있도록 보장하며, 예측 불가능한 결과나 오류를 방지합니다.

---

## 2. 동시성 제어의 원리

Java에서의 동시성 제어는 **상호 배제(Mutual Exclusion)**와 **메모리 가시성(Memory Visibility)**을 보장하는 데 중점을 둡니다.

1. **락 획득 (Lock Acquisition)**  
   스레드가 임계 영역에 진입하기 위해 먼저 락을 획득합니다. 다른 스레드가 이미 락을 보유 중이면, 해당 스레드는 락이 해제될 때까지 대기합니다.

2. **임계 영역 실행 (Critical Section Execution)**  
   락을 획득한 스레드는 공유 자원에 대한 안전한 작업을 수행합니다. 이 동안 다른 스레드는 해당 임계 영역에 접근할 수 없습니다.

3. **락 해제 (Lock Release)**  
   작업이 완료되면, 스레드는 락을 해제하여 다른 스레드가 임계 영역에 접근할 수 있도록 합니다.

4. **메모리 가시성 (Memory Visibility)**  
   락의 획득과 해제는 스레드 간 작업 결과가 올바르게 전달되도록 보장합니다. 이를 통해 한 스레드의 작업이 다른 스레드에게 즉시 반영되어 데이터 일관성을 유지할 수 있습니다.

---

## 3. 자바에서의 동시성 제어 방식

### 3.1 `synchronized`

- **설명**  
  `synchronized` 키워드는 메서드나 코드 블록에 적용되어 임계 영역을 지정합니다. 지정된 영역에 진입하는 스레드는 반드시 락을 획득해야 하며, 임계 영역을 벗어나면 자동으로 락이 해제됩니다.

- **장점**
    - **간결성:** 문법이 단순하여 구현 및 사용이 쉽습니다.
    - **자동 관리:** 락 획득과 해제가 자동으로 이루어지므로, 개발자가 별도로 관리할 필요가 없습니다.

- **단점**
    - **유연성 부족:** 락 획득 방식에 대한 세밀한 제어(예: 대기 시간 제한, 공정성 정책 등)가 어렵습니다.
    - **범위 제한:** 메서드나 코드 블록 단위로만 락을 설정할 수 있어, 세밀한 자원 제어가 필요한 경우 적합하지 않을 수 있습니다.

---

### 3.2 `ReentrantLock`

- **설명**  
  `ReentrantLock`은 java.util.concurrent.locks 패키지에서 제공하는 락으로, 보다 세밀하고 유연한 동시성 제어를 지원합니다. 개발자가 명시적으로 락을 획득하고 해제할 수 있으며, 추가적인 기능(예: 공정성(fairness) 옵션, lockInterruptibly, tryLock, 다수의 Condition 객체 등)을 제공합니다.

- **장점**
    - **유연성:** 락 획득 시 시간 제한이나 인터럽트 처리 등의 다양한 옵션을 제공하여, 복잡한 동시성 요구사항을 보다 정밀하게 제어할 수 있습니다.
    - **세밀한 제어:** 특정 자원(예: ConcurrentMap의 특정 key)에 대해 개별 락을 적용할 수 있어, 불필요한 전체 동기화 없이 부분적 제어가 가능합니다.

- **단점**
    - **명시적 관리 필요:** 락 획득과 해제를 개발자가 직접 관리해야 하므로, 실수로 인한 데드락이나 락 누수가 발생할 위험이 있습니다.
    - **코드 복잡도 증가:** 사용법이 `synchronized`보다 복잡하여, 유지보수 시 주의가 필요합니다.

### 3.3 `synchronized` 과 `ReentrantLock` 비교

| 특성/기능           | `synchronized`                       | `ReentrantLock`                                  |
|---------------------|--------------------------------------|--------------------------------------------------|
| **사용 편의성**      | 간단하며 자동으로 락 해제              | 명시적 락 관리 필요, 코드가 복잡할 수 있음           |
| **유연성**           | 기본적인 동기화 지원                  | 공정성, 락 인터럽트, tryLock 등 다양한 옵션 제공      |
| **성능**             | 단순한 경우 오버헤드 적음               | 복잡한 동시성 제어에 효과적이나, 잘못 사용 시 성능 저하 가능 |
| **제어 범위**        | 메서드나 코드 블록 단위로 제한           | 특정 객체나 키 단위로 세밀하게 제어 가능             |

---

## 5. `ReentrantLock`을 선택한 이유 (with ConcurrentMap)

- **세밀한 자원 제어**
   
    포인트 충전은 각 유저별로 동시에 여러 건의 요청이 들어올 수 있으며, 이를 순차적으로 처리해야 합니다. `ReentrantLock`과 `ConcurrentMap`을 사용하면 특정 유저에 대한 락을 설정하여, 해당 유저의 충전 요청을 순차적으로 처리할 수 있습니다. 
    이를 통해 불필요한 전체 동기화를 피하고, 자원에 대해 더 높은 수준의 병렬성을 확보할 수 있습니다.

---

## 6. `AOP`를 활용한 이유
- **코드 중복 최소화**  
  AOP를 활용하면, 동시성 제어 로직을 따로 모듈화하여 서비스 로직에 집중할 수 있습니다. 이를 통해 코드 중복을 최소화하고, 락 관리에 대한 일관성을 유지할 수 있습니다.

- **사용 예시**
```java
@ConcurrencyControl(key = "'lock-key' + #id", timeout = 10L, timeUnit = TimeUnit.SECONDS)
public UserPoint charge(long id, long amount) {
    UserPoint userPoint = userPointTable.selectById(id);

    pointValidator.validateCharge(userPoint,  amount);
    UserPoint savedPoint = userPointTable.insertOrUpdate(userPoint.id(), userPoint.point() + amount);
    pointHistoryTable.insert(userPoint.id(), amount, TransactionType.CHARGE, savedPoint.updateMillis());

    return savedPoint;
}
```
---

## 7. 결론

이번 보고서에서는 동시성 제어의 기본 개념과 JVM이 제공하는 원리를 바탕으로, Java에서 사용 가능한 두 가지 동시성 제어 방식인 `synchronized`와 `ReentrantLock`의 특징 및 장단점을 살펴보았습니다. 또한, 포인트 충전과 같이 유저별 동시성 제어가 필요한 상황에서 `ReentrantLock`과 `ConcurrentMap`을 활용해 세밀한 자원 제어를 구현하는 방법과, `AOP`를 통한 코드 중복 최소화의 이점을 논의하였습니다.

이와 같이 적절한 동시성 제어 기법의 선택과 효과적인 코드 모듈화를 통해, 데이터의 일관성과 무결성을 보장하면서도 높은 성능을 유지할 수 있습니다. 이러한 접근 방식은 동시성 문제로 인한 오류와 데드락을 예방하여, 안정적이고 확장 가능한 애플리케이션 개발에 기여할 것입니다.